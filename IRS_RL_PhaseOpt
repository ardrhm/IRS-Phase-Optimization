function IRS_RL_PhaseOpt_AC()
B = 10e6;
noisePower = 10^((-174 + 10*log10(B) + 5 - 30)/10);

params = struct( ...
    'centerFreqHz', 12e9, ...
    'cLight',       3e8, ...
    'distTxToIRS',  80, ...
    'sceneSize',    20, ...
    'numTxAnt',     4, ...
    'numRxAnt',     4, ...
    'numIRS',       16, ...
    'txPower',      0.01, ...
    'noisePower',   noisePower, ...
    'ricianFactor', 5, ...
    'numEpisodes',  500, ...
    'numSteps',     50, ...
    'gamma',        0.99, ...
    'lr0',          5e-4, ...
    'noise0',       pi/2, ...
    'criticLR0',    2e-4, ...
    'criticHidden', 16, ...
    'gradClip',     1.0, ...
    'stepSize',     0.25, ...
    'seed',         42);

params.lrDecay       = @(ep) params.lr0       / sqrt(1 + 0.01*ep);
params.noiseDecay    = @(ep) params.noise0    * exp(-0.001*ep);
params.criticLRDecay = @(ep) params.criticLR0 / sqrt(1 + 0.01*ep);

rng(params.seed);

stateDim = 2 + 2 + params.numIRS;
actorNet = initNetwork(stateDim, params.numIRS, 32);
criticNet = initNetwork(stateDim, 1, params.criticHidden);
rewardHistory = zeros(params.numEpisodes,1);

for ep = 1:params.numEpisodes
    lr       = params.lrDecay(ep);
    sigma    = max(params.noiseDecay(ep),1e-4);
    criticLR = params.criticLRDecay(ep);

    [pos,env] = resetEnvironment(params);
    prevPos = pos; prevVel = [0;0]; prevPh = zeros(params.numIRS,1);

    trans.S  = cell(params.numSteps,1);
    trans.h1 = cell(params.numSteps,1);
    trans.mu = cell(params.numSteps,1);
    trans.A  = cell(params.numSteps,1);
    trans.R  = zeros(params.numSteps,1);

    for t = 1:params.numSteps
        s = [prevPos; prevVel; prevPh];
        [ph,mu,h1] = forwardPass(actorNet,s,sigma);
        ph = mod(ph,2*pi);
        [newPos,r,env] = environmentStep(ph,env,params);
        vel = newPos - prevPos;

        trans.S{t}  = s;
        trans.h1{t} = h1;
        trans.mu{t} = mu;
        trans.A{t}  = ph;
        trans.R(t)  = r;

        prevPos = newPos;
        prevVel = vel;
        prevPh  = ph;
    end

    G = computeDiscountedReturns(trans.R,params.gamma);

    for t = 1:params.numSteps
        s = trans.S{t};
        [v,h1c] = criticForward(criticNet,s);
        delta = G(t) - v;
        [dW1,db1,dW2,db2] = criticGradients(criticNet,s,h1c,delta);
        criticNet.W1 = criticNet.W1 + criticLR * clipNorm(dW1,params.gradClip);
        criticNet.b1 = criticNet.b1 + criticLR * clipNorm(db1,params.gradClip);
        criticNet.W2 = criticNet.W2 + criticLR * clipNorm(dW2,params.gradClip);
        criticNet.b2 = criticNet.b2 + criticLR * clipNorm(db2,params.gradClip);
    end

    adv = zeros(params.numSteps,1);
    for t = 1:params.numSteps
        v = criticForward(criticNet,trans.S{t});
        adv(t) = G(t) - v;
    end
    adv = (adv - mean(adv)) ./ (std(adv) + 1e-8);

    actorNet = updatePolicyAC(actorNet,trans,adv,lr,sigma,params.gradClip);
    rewardHistory(ep) = sum(trans.R);

    if mod(ep,10) == 0
        fprintf('Ep %3d/%3d  Reward=%.3f  lr=%.3g  σ=%.2f\n',ep,params.numEpisodes,rewardHistory(ep),lr,sigma);
    end
end

figure;
plot(rewardHistory,'LineWidth',1.5);
xlabel('Episode'); ylabel('Cumulative Reward (bits)');
title('IRS Phase Optimisation via Actor–Critic');
grid on;
end

function net = initNetwork(inD,outD,hid)
net.W1 = sqrt(2/(inD+hid))*randn(hid,inD);
net.b1 = zeros(hid,1);
net.W2 = sqrt(2/(hid+outD))*randn(outD,hid);
net.b2 = zeros(outD,1);
end

function [a,mu,h1] = forwardPass(net,s,sigma)
h1 = tanh(net.W1*s + net.b1);
mu = net.W2*h1 + net.b2;
a  = mu + sigma*randn(size(mu));
end

function [nextPos,r,env] = environmentStep(ph,env,params)
env.userPos = env.userPos + params.stepSize*(rand(2,1)-0.5)*2;
env.userPos = max(min(env.userPos,params.sceneSize),-params.sceneSize);
pos = env.userPos;
[Hd,Hti,Hir] = generateChannel(pos,params);
H = Hd + Hir * diag(exp(1j*ph)) * Hti;
rho = (params.txPower/params.numTxAnt)/params.noisePower;
M = eye(params.numRxAnt) + rho*(H*H');
r = log2detSPD(M);
nextPos = pos;
end

function v = log2detSPD(M)
[L,p] = chol(M,'lower');
if p == 0
    v = 2*sum(log(diag(L)))/log(2);
else
    e = eig((M+M')/2);
    e(e<realmin) = realmin;
    v = sum(log2(e));
end
end

function [Hd,Hti,Hir] = generateChannel(pos,params)
lam = params.cLight / params.centerFreqHz;
K   = params.ricianFactor;

dDR = max(norm(pos),1);
azDR = atan2(pos(2),pos(1));
Hd = buildRician(steer(params.numRxAnt,azDR,lam)*steer(params.numTxAnt,azDR,lam)',dDR,lam,K);

IRS = [params.distTxToIRS;0];
dTI = max(norm(IRS),1);
azTI = atan2(IRS(2),IRS(1));
Hti = buildRician(steer(params.numIRS,azTI,lam)*steer(params.numTxAnt,azTI,lam)',dTI,lam,K);

vec = pos - IRS;
dIR = max(norm(vec),1);
azIR = atan2(vec(2),vec(1));
Hir = buildRician(steer(params.numRxAnt,azIR,lam)*steer(params.numIRS,azIR,lam)',dIR,lam,K);
end

function H = buildRician(los,dist,lam,K)
[Nr,Nt] = size(los);
los = los / norm(los,'fro') * sqrt(Nr*Nt);
nlos = (randn(Nr,Nt)+1i*randn(Nr,Nt))/sqrt(2);
PL  = (lam/(4*pi*dist))^2;
H   = sqrt(PL)*(sqrt(K/(K+1))*los + sqrt(1/(K+1))*nlos);
end

function a = steer(N,az,lam)
d = lam/2;
m = (0:N-1).';
a = exp(-1j*2*pi*d*m*sin(az)/lam);
a = a / norm(a);
end

function [pos,env] = resetEnvironment(params)
pos = (rand(2,1)-0.5)*2*params.sceneSize;
env.userPos = pos;
end

function G = computeDiscountedReturns(R,g)
T = numel(R);
G = zeros(T,1);
acc = 0;
for t = T:-1:1
    acc = R(t) + g*acc;
    G(t) = acc;
end
end

function [v,h1] = criticForward(net,s)
h1 = tanh(net.W1*s + net.b1);
v  = net.W2*h1 + net.b2;
end

function [dW1,db1,dW2,db2] = criticGradients(net,s,h1,delta)
dW2 = delta * h1.';
db2 = delta;
d1  = (net.W2.'*delta) .* (1 - h1.^2);
dW1 = d1 * s.';
db1 = d1;
end

function net = updatePolicyAC(net,trans,adv,lr,sigma,gmax)
dW1 = zeros(size(net.W1));
db1 = zeros(size(net.b1));
dW2 = zeros(size(net.W2));
db2 = zeros(size(net.b2));
invS2 = 1/(sigma^2);
T = numel(trans.R);
for t = 1:T
    s  = trans.S{t};
    h1 = trans.h1{t};
    mu = trans.mu{t};
    a  = trans.A{t};
    A  = adv(t);
    err = angle(exp(1j*(a - mu)));
    dp  = err * invS2;
    dW2 = dW2 + (dp * h1.') * A;
    db2 = db2 + dp * A;
    d1  = (net.W2.' * dp) .* (1 - h1.^2);
    dW1 = dW1 + (d1 * s.') * A;
    db1 = db1 + d1 * A;
end
net.W1 = net.W1 + lr * clipNorm(dW1,gmax);
net.b1 = net.b1 + lr * clipNorm(db1,gmax);
net.W2 = net.W2 + lr * clipNorm(dW2,gmax);
net.b2 = net.b2 + lr * clipNorm(db2,gmax);
end

function x = clipNorm(x,gmax)
n = norm(x(:));
if n > gmax
    x = x * (gmax/n);
end
end
