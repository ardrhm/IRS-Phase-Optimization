function IRS_RL_PhaseOpt_AC()
    params = struct( ...
        'centerFreqHz',12e9,'cLight',3e8, ...
        'distTxToIRS',80,'distIRSToRx',20,'sceneSize',20, ...
        'numTxAnt',4,'numRxAnt',4,'numIRS',16, ...
        'txPower',0.01,'noisePower',1e-10,'ricianFactor',5, ...
        'numEpisodes',500,'numSteps',50,'gamma',0.99, ...
        'lr0',5e-4,'noise0',pi/2,'criticLR0',2e-4,'criticHidden',16, ...
        'gradClip',1.0,'stepSize',0.25,'seed',42 ...
    );
    params.lrDecay        = @(ep) params.lr0        / sqrt(1 + 0.01*ep);
    params.noiseDecay     = @(ep) params.noise0     * exp(-0.001*ep);
    params.criticLRDecay  = @(ep) params.criticLR0  / sqrt(1 + 0.01*ep);
    rng(params.seed);

    stateDim   = 2 + 2 + params.numIRS;
    actorNet   = initNetwork(stateDim, params.numIRS,        32);
    criticNet  = initNetwork(stateDim, 1,            params.criticHidden);

    rewardHistory = zeros(params.numEpisodes,1);

    for ep = 1:params.numEpisodes
        lr       = params.lrDecay(ep);
        sigma    = params.noiseDecay(ep);
        criticLR = params.criticLRDecay(ep);

        trans = struct();
        adv   = zeros(params.numSteps,1);

        [pos,env] = resetEnvironment(params);
        prevPos   = pos;
        prevVel   = [0;0];
        prevPh    = zeros(params.numIRS,1);

        for t = 1:params.numSteps
            s = [prevPos; prevVel; prevPh];
            [ph,mu,h1]   = forwardPass(actorNet, s, sigma);
            ph           = mod(ph,2*pi);
            [newPos,r,env] = environmentStep(ph, env, params);
            vel = newPos - prevPos;

            trans.S{t}  = s;
            trans.h1{t} = h1;
            trans.mu{t} = mu;
            trans.A{t}  = ph;
            trans.R(t)  = r;

            prevPos = newPos;
            prevVel = vel;
            prevPh  = ph;
        end

        G = computeDiscountedReturns(trans.R, params.gamma);

        for t = 1:params.numSteps
            s  = trans.S{t};
            [v,h1] = criticForward(criticNet, s);
            delta  = G(t) - v;
            [dW1,db1,dW2,db2] = criticGradients(criticNet, s, h1, delta);

            dW1 = clipNorm(dW1, params.gradClip);
            db1 = clipNorm(db1, params.gradClip);
            dW2 = clipNorm(dW2, params.gradClip);
            db2 = clipNorm(db2, params.gradClip);

            criticNet.W1 = criticNet.W1 + criticLR * dW1;
            criticNet.b1 = criticNet.b1 + criticLR * db1;
            criticNet.W2 = criticNet.W2 + criticLR * dW2;
            criticNet.b2 = criticNet.b2 + criticLR * db2;
        end

        for t = 1:params.numSteps
            s      = trans.S{t};
            [v,~]  = criticForward(criticNet, s);
            adv(t) = G(t) - v;
        end
        adv = (adv - mean(adv)) ./ (std(adv) + 1e-8);

        actorNet = updatePolicyAC(actorNet, trans, adv, lr, sigma, params.gradClip);
        rewardHistory(ep) = sum(trans.R);

        if mod(ep,10)==0
            fprintf('Ep %3d/%3d  Reward=%.3f  lr=%.3g  Ïƒ=%.3g\n', ...
                    ep, params.numEpisodes, rewardHistory(ep), lr, sigma);
        end
    end

    figure;
    plot(rewardHistory,'LineWidth',1.5);
    xlabel('Episode'); ylabel('Cumulative Reward (bits)');
    title('IRS Phase Optimization via Actor-Critic');
    grid on;
end

function net = initNetwork(inD,outD,hid)
    net.W1 = sqrt(2/(inD+hid))*randn(hid,inD);
    net.b1 = zeros(hid,1);
    net.W2 = sqrt(2/(hid+outD))*randn(outD,hid);
    net.b2 = zeros(outD,1);
end

function [action,mu,h1] = forwardPass(net,s,sigma)
    h1     = tanh(net.W1*s + net.b1);
    mu     = net.W2*h1 + net.b2;
    action = mu + sigma*randn(size(mu));
end

function [nextPos,reward,env] = environmentStep(ph,env,params)
    env.userPos = env.userPos + params.stepSize*(rand(2,1)-0.5)*2;
    pos = env.userPos;
    [Hd,Hti,Hir] = generateChannel(pos,params);
    Htot   = Hd + (Hir * diag(exp(1j*ph)) * Hti);
    reward = log2(1 + (params.txPower * norm(Htot,'fro')^2) / params.noisePower);
    nextPos = pos;
end

function [Hd,Hti,Hir] = generateChannel(pos,params)
    lam = params.cLight / params.centerFreqHz;
    K   = params.ricianFactor;

    dDR = norm(pos);
    Hd  = buildRician(...
        steeringVec(params.numRxAnt,atan2(pos(2),pos(1)),lam) * ...
        steeringVec(params.numTxAnt,atan2(pos(2),pos(1)),lam)', ...
        dDR, lam, K);

    IRSpos = [params.distTxToIRS; 0];
    dTI    = norm(IRSpos);
    azTI   = atan2(IRSpos(2),IRSpos(1));
    Hti    = buildRician(...
        steeringVec(params.numIRS,azTI,lam) * ...
        steeringVec(params.numTxAnt,azTI,lam)', ...
        dTI, lam, K);

    vecIR  = pos - IRSpos;
    dIR    = norm(vecIR);
    azIR   = atan2(vecIR(2),vecIR(1));
    Hir    = buildRician(...
        steeringVec(params.numRxAnt,azIR,lam) * ...
        steeringVec(params.numIRS,azIR,lam)', ...
        dIR, lam, K);
end

function M = buildRician(los,dist,lam,K)
    [Nr,Nt] = size(los);
    nlos    = (randn(Nr,Nt) + 1i*randn(Nr,Nt)) / sqrt(2);
    PL      = (lam/(4*pi*dist))^2;
    M       = sqrt(PL)*(sqrt(K/(K+1))*los + sqrt(1/(K+1))*nlos);
end

function a = steeringVec(N,az,lam)
    d      = lam/2;
    m      = (0:N-1).';
    a      = exp(-1j*2*pi*d*m*sin(az)/lam);
    a      = a / norm(a);
end

function [pos,env] = resetEnvironment(params)
    pos        = (rand(2,1)-0.5) * 2 * params.sceneSize;
    env.userPos = pos;
end

function G = computeDiscountedReturns(R,g)
    T = numel(R); G=zeros(T,1); acc=0;
    for t = T:-1:1
        acc   = R(t) + g*acc;
        G(t)  = acc;
    end
end

function [v,h1] = criticForward(net,s)
    h1 = tanh(net.W1*s + net.b1);
    v  = net.W2*h1 + net.b2;
end

function [dW1,db1,dW2,db2] = criticGradients(net,s,h1,delta)
    dW2 = delta * h1.';
    db2 = delta;
    d1  = (net.W2.'*delta) .* (1 - h1.^2);
    dW1 = d1 * s.';
    db1 = d1;
end

function net = updatePolicyAC(net,trans,adv,lr,sigma,gmax)
    dW1=zeros(size(net.W1)); db1=zeros(size(net.b1));
    dW2=zeros(size(net.W2)); db2=zeros(size(net.b2));
    invs2 = 1 / sigma^2;
    for t = 1:numel(trans.R)
        s  = trans.S{t};
        h1 = trans.h1{t};
        mu = trans.mu{t};
        a  = trans.A{t};
        A  = adv(t);
        dp = (a - mu) * invs2;
        dW2 = dW2 + (dp * h1.') * A;
        db2 = db2 + dp * A;
        d1  = (net.W2.' * dp) .* (1 - h1.^2);
        dW1 = dW1 + (d1 * s.') * A;
        db1 = db1 + d1 * A;
    end
    dW1 = clipNorm(dW1, gmax);
    db1 = clipNorm(db1, gmax);
    dW2 = clipNorm(dW2, gmax);
    db2 = clipNorm(db2, gmax);

    net.W1 = net.W1 + lr * dW1;
    net.b1 = net.b1 + lr * db1;
    net.W2 = net.W2 + lr * dW2;
    net.b2 = net.b2 + lr * db2;
end

function x = clipNorm(x, gmax)
    n = norm(x(:));
    if n > gmax, x = x * (gmax/n); end
end
